系统调用原理：
    https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#what-is-a-system-call



1. 组成：
    - 基本内核组件：定时器/系统时钟处理/描述符管理/进程管理
    - 内存管理：分页/交换
    - 普通系统接口：IO，控制，多路复用
    - 文件系统：文件，目录，加锁，文件IO缓冲区管理
    - 终端管理
    - 进程间通信
    - 网络通信：底层协议，路由等

    进程管理：4.4BSD的进程上下文由用户级状态(地址空间的内容/运行时环境)以及内核级状态(调度参数/资源控制/标识信息)。
        内核通过复制另一个进程上下文的方式创建一个新的进程。

        进程  (fork)-> 子进程 (execv族)-> 子进程 (exit)-> 僵尸进程

    内存管理：进程执行时其地址空间的所有内容不一定会全部被调入内存，当引用还没有调入主内存的地址空间时系统会自动将需要的页面
        调入内存,即按需调页(demand paging)。

        内存映射mmap相关->进程可以在其任意地址空间开启共享文件映射，也可以对同一个文件开启共享映射来共享它们的地址空间
        系统调用时执行信息传入内核的途径有
            ①将数据从用户空间复制到内核缓冲区中
            ②如果有大量数据需要传输的话复制会花费大量时间，这时候需要将用户进程的地址空间重新映射到内核上
    
    IO系统：UNIX用描述符来引用IO流，描述符代表内核支持的底层对象，由标明对象类型的系统调用所创建。可以描述3种对象：文件/管道/套接字
        - 文件：至少有一个名字的线性字节数组。当文件的所有名字都被删除且没有进程拥有指向它的描述符时该文件才被删除。
            open/read/write/close
        - 管道：无名字的线性字节数组。单向，通过系统调用pipe打开。 系统也支持命名管道或FIFO，FIFO出现在文件系统且可以用open打开。
        - 套接字：进程间通信所使用的暂存对象。

        内核为每个进程维护一个描述符表，一个进程的描述符表最初由父进程处继承下来，每个描述符都由对应的文件偏移量。
        进程的0/1/2号描述符由登录进程login process通过fork+exec传递给用户进程打开。
        dup建立了描述符的副本，与原描述符指向相同的文件表入口。
        硬件设备分为块设备和字符设备，内核对面向块的结构化设备支持读-修改-写的缓冲操作，允许它们以一种字节地址的方式完全随机读写。


2. 内核服务
    - 内核运行时结构：
        + 用户例程：抢占调度不能阻塞，在用户地址空间允许用户栈直到被阻塞或完成时才开始运行
        + 内核上半部：可以阻塞等待资源；在每个进程的内核栈上运行
        + 内核下半部：从不调度，不能阻塞。在内核地址空间的内核栈上运行
    - 系统调用：        
        + 时钟中断：
            系统每过一段时间就会响应一个时钟中断，称为tick，每次tick系统都会更新当前系统时间/进程时间/系统计时器等。
            tick在一个很高的硬件中断优先级上运行，保存进程状态后将调用hardclock()例程。
            hardclock():
                + 使系统当前时间继续正常递增
                + 如果当前进程有一个虚拟的进程时间计数器，将计时器时间递减，并在期满时发送一个信号(比如SIGALRM)
                + 如果系统没有一个独立的统计数据收集用的时钟，则hardclock()负责statclock()的工作
                + 如果需要调用softclock()且当前中断优先级比较低，则直接调用softclock()

            statclock():
                statclock单独由一个时钟支持，负责统计进程的资源使用情况。
                + 使用tick管理当前运行的进程，如果一个进程已经运行了4个tick则重新计算其优先级。如果新的优先级比当前低，则重新调度该进程。
                + 收集tick时间内系统中运行中任务的相关统计数据，包括I/O等信息。
            
            softclock():
                其余时间相关操作，比如处理超时请求和周期性地重新设置将要运行的进程的优先级等工作交由softclock处理。
                + 处理实时计时器
                + 重新传送丢下的网络数据包
                + 针对需要监控的外围设备的监控计时器
                + 系统进程重新调度的事件,比如根据当前CPU使用情况周期性调整每个进程的CPU优先级
        
        系统为每个进程提供3个间隔定时器：
            + real timer：随着时间推进而减少，例如维护一个唤醒服务队列，定时器到点时发送SIGALARM信号给进程。
                它是基于softclock维护的超时队列基础上运行的。
            + profiling timer：只有在进程虚拟时间上(运行在用户模式时)和系统为该进程服务时才递减。用于进程统计和执行时间配置，超时发送SIGPROF信号。
                它在hardclock里实现，每次hardclock运行时都会检查一次。
            + virtual timer：在进程的虚拟时间中作递减操作。只有进程的用户模式执行时才运行。超时后发送SIGVTALRM信号给进程。
                在hardclock中实现。
            
    - 内存管理：
        + 进程开始执行时，内核将文件代码片段映射到进程地址空间的低端，然后映射文件初始化数据，

            text(文本)  ->  data(已初始化全局变量)  ->  bss(未初始化的全局变量)  ->  heap
                -> 共享库/mmap映射区  ->  stack  -> 内核段

3. 进程管理
    - 


4. 内存管理
    - 系统启动步骤：
        + 将内核映像从磁盘/网络上加载到物理内存，内核映像和普通程序相似包括代码段、初始化和未初始化的数据段。
            此时MMU部件是关闭的，因此不像用户进程那样分页，所有寻址以绝对物理地址进行。
        + 内核启动后第一步即创建内核pmap(physical mapping)和别的数据结构，以便启动别的内核模块。



5. 通信
    - 层次          示例
      套接字层      流套接字
      网络协议      TCP/IP
      网络接口      10Mbit/s以太网
    
    - 套接字的内存管理
        
